# 介绍
用于学习C++语法。
# 模板Template
**模板(Template)**指C++程序设计语言中采用**类型**作为**参数**的程序设计，以支持通用程序设计，在java等语言中的**泛型**类似。通常有两种形式：**函数模板**和**类模板**。需要借助关键字**template**和**typename**或者**class**。
## 函数模板
### 语法
```C++
template <class T1, class T2, class ...>
返回类型 函数名（参数列表）
{
    // 函数体
}

template <typename T>
void swap(T& a, T& b){}
```
其中**class可以用typename关键字代替**。
### 普通函数与模板函数的调用
- 普通函数的调用：**可以进行隐式的类型转换**
- 函数模板的调用：（本质：类型参数化）将严格按照类型进行匹配，**不会进行自动类型转换**。
### 函数模板的调用规则
- 函数模板可以像普通函数一样重载,也可以和同名普通函数一样一起构成重载；
- 普通函数与模板函数都**严格满足调用条件(同名普通函数不进行隐式转换）**时，C++编译器优先考虑普通函数；
- 如果函数模板可以产生一个**更好的匹配（同名普通函数可以隐式转换来满足，但模板直接满足）**，那么选择模板；
- 可以通过**空模板**实参列表 限定编译器只通过模板匹配；
```C++
template <typename T>
T Max(T a, T b);
T Max(T a, T b, T c);
int Max(int a, int b); // 三个函数都重载

Max(1, 2); // 严格满足 int Max(int a, int b) 和 T Max(T a, T b);优先代用普通函数
Max(1.0, 2.0) // 更满足T Max(T a, T b) 普通函数需要隐式转换才满足
Max<>(1, 2); // 使用空模板参数列表，只通过模板匹配调用
```
### 函数模板机制
- 编译器并不是把函数模板处理成能够处理任意类的函数；
- 编译器从函数模板通过具体类型**产生不同的函数**，帮程序员做了这些类型函数的工作；
- 编译器会对函数模板进行**两次编译**；
> **在声明的地方对模板代码本身**进行编译；**在调用的地方对参数替换后的代码**进行编译。
## 类模板
### 语法
```C++
template <typename T1, typename T2, typename ...>
class A
{

}
```
### 模板类派生为普通类
子类从模板类继承的时候,需要让编译器知道 父类的数据类型具体是什么(**数据类型的本质:固定大小内存块的别名**)。
```C++
// 模板类派生普通的类
// 派生时，父类需要指定类型
// 这里不需要写 template ，只需要指定父类的类型
class B:public A<int>
{
private:
    int mB;
public:
    B(int b, int a);
    ~B();
};

// 因为父类A只有有参构造函数，因此需要在构造列表中初始化
B::B(int b, int a):A<int>(a)
{
    mB = b;
}
```
**模板类是抽象的 ===》 需要进行具体化；编译器得知道怎么给它分配内存**
### 模板类派生模板类
**在声明的地方用到了父类，就需要指明父类的类型T.** 在**类外的实现成员函数**，都需要template声明，写凡声明的类类型不确定，都需要**模板列表指明**,而类内 和 函数类不需要。
```C++
// 模板类派生模模板类
// 需要声明派生的类型 T
//派生时，需要指定父类派生的类型T
template <typename T>
class C:public A<T> 
{
private:
    T mC;
public:
    C(T c, T a); // 类内，因此C后面不需要模板列表指明类型
    void print();
};

template <typename T>
C<T>::C(T c, T a): A<T>(a)
{
    mC = c;
}
```
### 所有的类模板函数写在类的外部，在一个cpp中
- 在类外的声明中用到了模板就要显示的声明类型T，函数内部可以不用申明
- 友元函数：用友元函数重载 << >>，**其他时候使用友元属于滥用**，**强烈建议模板的友元函数写在类中实现，不然很容易出问题**，因为友元函数不是类内函数，是外部函数，不能用类的域名指定。
### 类模板声明与实现分开在两个文件里
1. 如果分开放在M.h 与 M.cpp
当别的文件include M.h，是会编译失败的，因为模板实现的原理需要二次编译，因此需要include "M.cpp"才行，一般会把.cpp 改为后缀.hpp。
2. 建议把模板类都写在.h文件里，这样只要include <M.h>就可以了。
因为模板的机制是二次编译，分开写而值应用声明，在二次编译时会找不到。
### 类模板中的static关键字
1. 从类模板实例化的**每个模板类有自己的类模板数据成员**，该模板类的所有对象共享一个static数据成员
2. **和非模板类的static数据成员一样，模板类的static数据成员也应该在文件范围定义和初始化**
3. **每个模板类有自己的类模板的static数据成员副本**
### 应用中需要注意的地方
1. **所有容器提供的都是值（value）语意，而非引用（reference）语意**。容器执行插入元素的操作时，内部实施拷贝动作。所以STL容器内存储的元素必须能够被拷贝（**必须提供拷贝构造函数**）。
2. 如果模板涉及到new T[] 操作，应当给对应的T加上默认构造函数，不然会失败
``` c++
// 需要无参构造函数，因为会被使用为new teacher[size],这条语句需要无参构造函数
    teacher()
    {
        name = new char[1];
        name[0] = '\0';
        age = 0;
    }
```
# 类型转换
## 语法
### C风格类型转换
- type b = (type)a
### C++风格类型转换
- static_cast 静态类型转换。如int转换成char
- reinterpreter_cast 重新解释类型，类似于强制转换，但更强
- dynamic_cast 命名上理解是动态类型转换。如子类和父类之间的多态类型转换。
- const_cast 字面上理解就是去const属性
- 使用方式为`newtype new = xxx_cast<newtype> old`
### 一般性介绍
1. static_cast<>() 静态类型转换，**编译时c++编译器会做类型检查；
2. 一般性结论：
- C语言中  能**隐式类型转换**的，在c++中可用 static_cast<>()进行类型转换。因C++编译器在编译检查一般都能通过；
- C语言中**不能隐式类型转换**的，在c++中可以用reinterpret_cast<>() 进行强行类型解释。
- reinterpret_cast<>()很难保证移植性。
- dynamic_cast<>()，**动态类型转换**，安全的基类和子类之间转换；**运行时类型检查**；一般用于检查参数能否转化我特定的子类。
```c++
void ObjPlay(Animal *base) // 参数为一个父类
{
	base->cry();
	Dog *pDog = dynamic_cast<Dog *>(base); // 判断是否是某个子类
	if (pDog != NULL)
	{
		pDog->cry();
		pDog->doSwim();
	}

	Cat *pCat = dynamic_cast<Cat *>(base);
	if (pCat != NULL)
	{
		pCat->cry();
		pCat->doTree();
	}
}
```
- const_cast<>()，去除变量的**只读属性**
```c++
//典型用法 把形参的只读属性去掉
void Opbuf(const char *p)
{
	cout << p << endl;
	char *p2 = const_cast<char*>(p);
	p2[0] = 'b';
	cout << p << endl;
}

const char *p1 = "11111111111"; // 只读

char *p2 = "22222222"; // 可读

char *p3 = const_cast<char *>(p1); // 去只读属性
char buf[100] = "aaaaaaaaaaaa"; 

//要保证指针所执行的内存空间能修改才行 若不能修改 还是会引起程序异常
//Opbuf("dddddddddddsssssssssssssss"); // 因为”dddd.."是在字符表中的，没有内存空间，不可以修改
```
3. 总结
- static_cast<>()和reinterpret_cast<>() 基本上把C语言中的 强制类型转换给覆盖
- 程序员要清除的知道: 要转的变量，类型转换前是什么类型，类型转换后是什么类型。转换后有什么后果。
- **一般情况下，不建议进行类型转换；避免进行类型转换**
# 异常Exception
- 异常是一种程序控制机制，与函数机制独立和互补
- 异常在错误处理方面活动最大的好处
## 传统错误处理机制
- 通过返回值，对不同的返回值处理，确定在于不够直观，也让返回值变成了错误处理机制，而不是需要的结果
## 异常处理的基本思想
- C++的异常处理机制使得异常的引发和异常的处理不必在同一个函数中，这样底层的函数可以着重解决具体问题，而不必过多的考虑异常的处理。上层调用者可以再适当的位置设计对不同类型异常的处理。
- 异常超脱于函数机制，决定了其对函数的**跨越式回跳**。
## 语法
### 抛掷异常
```c++
void fun()
{
	...
	throw 表达式(一般是个类型或者对象)
	...
}
```
### 捕获异常并处理异常的程序段
```c++
try 
{
	复合语句 //需要捕获异常的代码
}
catch (异常类型声明)
{
	处理异常
}
catch (类型 （可选形参)
{
	异常处理
}
catch (...) // 匹配任何异常，一般是未知异常处理
{
	异常处理
	throw; //处理不了，往更上层调用抛出异常，让上层处理
}
...
```
1. 若有异常则通过throw操作**创建一个异常对象**并抛掷
2. 将可能抛出异常的程序段嵌在try块之中。控制通过正常的顺序执行到达try语句，然后执行try块内的保护段
3. 如果在保护段执行期间没有引起异常，那么跟在try块后的catch子句就不执行。程序从try块后跟随的最后一个catch子句后面的语句继续执行下去
4. **catch子句按其在try块后出现的顺序被检查**。匹配的catch子句将捕获并处理异常（或继续抛掷异常）
5. **如果匹配的处理器未找到，则运行函数terminate将被自动调用，其缺省功能是调用abort终止程序**
6. 处理不了的异常，可以在catch的最后一个分支，使用throw语法，向上扔
7. 异常机制与函数机制互不干涉，但捕捉的方式是**基于严格类型匹配**。捕捉相当于函数返回类型的匹配，而不是函数参数的匹配，所以捕捉不用考虑一个抛掷中的多种数据类型匹配问题。
8. **栈解旋(unwinding)**：异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。
### 异常接口声明
1. 为了加强程序的可读性，可以**在函数声明中列出可能抛出的所有异常类型**，如`void func() throw(A,B,C,D);` 这个函数func**能够且只能够抛出类型ABCD及其子类型的异常**;
2. 如果在函数声明中**没有包含异常接口声明**，则次函数可以抛掷任何类型的异常，如`void func();`;
3. 一个**不抛掷任何类型异常的函数**可以声明为`void func() throw();`
4. 如果一个函数抛出了它的异常接口声明所不允许抛出的异常，unexpected函数会被调用，该函数默认行为调用terminate函数中止程序。
### 抛出对象对象的异常
1. 抛出值对象`throw MyCat();` 记得是有括号的,捕捉时也需要用值去捕捉`catch(MyCat c)`, **抛出时会调用类的构造函数，捕获时调用类的赋值构造函数(因此要注意浅拷贝和深拷贝，默认的赋值构造函数是浅拷贝)**;
2. 抛出值对象`throw MyCat();`捕获时也需要用引用去捕捉`catch(MyCat &c)`，**抛出时会调用类的构造函数，捕获时获得构造函数创建的异常类型，不会进行赋值构造函数**;
3. 抛出对象指针`throw new MyCat();`, 捕获时也需要用指针去捕捉`catch(MyCat *c)`，**但因为是指针，涉及到资源的释放，需要在catch中手动的delete，不然容易造成内存泄漏（无法释放或为释放造成系统资源的浪费）**。
结论：C++编译器**通过throw 来产生对象**，C++编译器再执行对应的catch分支，**相当于一个函数调用，把实参传递给形参**。使用是最好**用引用去捕获，让c++gc去接管他们的声明周期，也避免了拷贝构造函数的问题**。
### 标准程序异常
1. 这些类以基类`Exception`开始，该基类提供了一个成员函数`what()`，用于返回错误信息（返回类型为const char *) 在`Exception`类中，`what()`函数的声明如下：
```
virtual const char* what() const throw();
```
